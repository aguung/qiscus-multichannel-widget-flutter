// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'subtitle_config.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$QSubtitleConfigTearOff {
  const _$QSubtitleConfigTearOff();

  _QSubtitleDisabled disabled() {
    return const _QSubtitleDisabled();
  }

  _QSubtitleEnabled enabled() {
    return const _QSubtitleEnabled();
  }

  _QSubtitleEditable editable(String subtitle) {
    return _QSubtitleEditable(
      subtitle,
    );
  }
}

/// @nodoc
const $QSubtitleConfig = _$QSubtitleConfigTearOff();

/// @nodoc
mixin _$QSubtitleConfig {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disabled,
    required TResult Function() enabled,
    required TResult Function(String subtitle) editable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_QSubtitleDisabled value) disabled,
    required TResult Function(_QSubtitleEnabled value) enabled,
    required TResult Function(_QSubtitleEditable value) editable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QSubtitleConfigCopyWith<$Res> {
  factory $QSubtitleConfigCopyWith(
          QSubtitleConfig value, $Res Function(QSubtitleConfig) then) =
      _$QSubtitleConfigCopyWithImpl<$Res>;
}

/// @nodoc
class _$QSubtitleConfigCopyWithImpl<$Res>
    implements $QSubtitleConfigCopyWith<$Res> {
  _$QSubtitleConfigCopyWithImpl(this._value, this._then);

  final QSubtitleConfig _value;
  // ignore: unused_field
  final $Res Function(QSubtitleConfig) _then;
}

/// @nodoc
abstract class _$QSubtitleDisabledCopyWith<$Res> {
  factory _$QSubtitleDisabledCopyWith(
          _QSubtitleDisabled value, $Res Function(_QSubtitleDisabled) then) =
      __$QSubtitleDisabledCopyWithImpl<$Res>;
}

/// @nodoc
class __$QSubtitleDisabledCopyWithImpl<$Res>
    extends _$QSubtitleConfigCopyWithImpl<$Res>
    implements _$QSubtitleDisabledCopyWith<$Res> {
  __$QSubtitleDisabledCopyWithImpl(
      _QSubtitleDisabled _value, $Res Function(_QSubtitleDisabled) _then)
      : super(_value, (v) => _then(v as _QSubtitleDisabled));

  @override
  _QSubtitleDisabled get _value => super._value as _QSubtitleDisabled;
}

/// @nodoc

class _$_QSubtitleDisabled implements _QSubtitleDisabled {
  const _$_QSubtitleDisabled();

  @override
  String toString() {
    return 'QSubtitleConfig.disabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _QSubtitleDisabled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disabled,
    required TResult Function() enabled,
    required TResult Function(String subtitle) editable,
  }) {
    return disabled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
  }) {
    return disabled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
    required TResult orElse(),
  }) {
    if (disabled != null) {
      return disabled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_QSubtitleDisabled value) disabled,
    required TResult Function(_QSubtitleEnabled value) enabled,
    required TResult Function(_QSubtitleEditable value) editable,
  }) {
    return disabled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
  }) {
    return disabled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
    required TResult orElse(),
  }) {
    if (disabled != null) {
      return disabled(this);
    }
    return orElse();
  }
}

abstract class _QSubtitleDisabled implements QSubtitleConfig {
  const factory _QSubtitleDisabled() = _$_QSubtitleDisabled;
}

/// @nodoc
abstract class _$QSubtitleEnabledCopyWith<$Res> {
  factory _$QSubtitleEnabledCopyWith(
          _QSubtitleEnabled value, $Res Function(_QSubtitleEnabled) then) =
      __$QSubtitleEnabledCopyWithImpl<$Res>;
}

/// @nodoc
class __$QSubtitleEnabledCopyWithImpl<$Res>
    extends _$QSubtitleConfigCopyWithImpl<$Res>
    implements _$QSubtitleEnabledCopyWith<$Res> {
  __$QSubtitleEnabledCopyWithImpl(
      _QSubtitleEnabled _value, $Res Function(_QSubtitleEnabled) _then)
      : super(_value, (v) => _then(v as _QSubtitleEnabled));

  @override
  _QSubtitleEnabled get _value => super._value as _QSubtitleEnabled;
}

/// @nodoc

class _$_QSubtitleEnabled implements _QSubtitleEnabled {
  const _$_QSubtitleEnabled();

  @override
  String toString() {
    return 'QSubtitleConfig.enabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _QSubtitleEnabled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disabled,
    required TResult Function() enabled,
    required TResult Function(String subtitle) editable,
  }) {
    return enabled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
  }) {
    return enabled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
    required TResult orElse(),
  }) {
    if (enabled != null) {
      return enabled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_QSubtitleDisabled value) disabled,
    required TResult Function(_QSubtitleEnabled value) enabled,
    required TResult Function(_QSubtitleEditable value) editable,
  }) {
    return enabled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
  }) {
    return enabled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
    required TResult orElse(),
  }) {
    if (enabled != null) {
      return enabled(this);
    }
    return orElse();
  }
}

abstract class _QSubtitleEnabled implements QSubtitleConfig {
  const factory _QSubtitleEnabled() = _$_QSubtitleEnabled;
}

/// @nodoc
abstract class _$QSubtitleEditableCopyWith<$Res> {
  factory _$QSubtitleEditableCopyWith(
          _QSubtitleEditable value, $Res Function(_QSubtitleEditable) then) =
      __$QSubtitleEditableCopyWithImpl<$Res>;
  $Res call({String subtitle});
}

/// @nodoc
class __$QSubtitleEditableCopyWithImpl<$Res>
    extends _$QSubtitleConfigCopyWithImpl<$Res>
    implements _$QSubtitleEditableCopyWith<$Res> {
  __$QSubtitleEditableCopyWithImpl(
      _QSubtitleEditable _value, $Res Function(_QSubtitleEditable) _then)
      : super(_value, (v) => _then(v as _QSubtitleEditable));

  @override
  _QSubtitleEditable get _value => super._value as _QSubtitleEditable;

  @override
  $Res call({
    Object? subtitle = freezed,
  }) {
    return _then(_QSubtitleEditable(
      subtitle == freezed
          ? _value.subtitle
          : subtitle // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_QSubtitleEditable implements _QSubtitleEditable {
  const _$_QSubtitleEditable(this.subtitle);

  @override
  final String subtitle;

  @override
  String toString() {
    return 'QSubtitleConfig.editable(subtitle: $subtitle)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _QSubtitleEditable &&
            const DeepCollectionEquality().equals(other.subtitle, subtitle));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(subtitle));

  @JsonKey(ignore: true)
  @override
  _$QSubtitleEditableCopyWith<_QSubtitleEditable> get copyWith =>
      __$QSubtitleEditableCopyWithImpl<_QSubtitleEditable>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disabled,
    required TResult Function() enabled,
    required TResult Function(String subtitle) editable,
  }) {
    return editable(subtitle);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
  }) {
    return editable?.call(subtitle);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
    required TResult orElse(),
  }) {
    if (editable != null) {
      return editable(subtitle);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_QSubtitleDisabled value) disabled,
    required TResult Function(_QSubtitleEnabled value) enabled,
    required TResult Function(_QSubtitleEditable value) editable,
  }) {
    return editable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
  }) {
    return editable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
    required TResult orElse(),
  }) {
    if (editable != null) {
      return editable(this);
    }
    return orElse();
  }
}

abstract class _QSubtitleEditable implements QSubtitleConfig {
  const factory _QSubtitleEditable(String subtitle) = _$_QSubtitleEditable;

  String get subtitle;
  @JsonKey(ignore: true)
  _$QSubtitleEditableCopyWith<_QSubtitleEditable> get copyWith =>
      throw _privateConstructorUsedError;
}
