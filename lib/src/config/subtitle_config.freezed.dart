// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'subtitle_config.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$QSubtitleConfig {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disabled,
    required TResult Function() enabled,
    required TResult Function(String subtitle) editable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_QSubtitleDisabled value) disabled,
    required TResult Function(_QSubtitleEnabled value) enabled,
    required TResult Function(_QSubtitleEditable value) editable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QSubtitleConfigCopyWith<$Res> {
  factory $QSubtitleConfigCopyWith(
          QSubtitleConfig value, $Res Function(QSubtitleConfig) then) =
      _$QSubtitleConfigCopyWithImpl<$Res>;
}

/// @nodoc
class _$QSubtitleConfigCopyWithImpl<$Res>
    implements $QSubtitleConfigCopyWith<$Res> {
  _$QSubtitleConfigCopyWithImpl(this._value, this._then);

  final QSubtitleConfig _value;
  // ignore: unused_field
  final $Res Function(QSubtitleConfig) _then;
}

/// @nodoc
abstract class _$$_QSubtitleDisabledCopyWith<$Res> {
  factory _$$_QSubtitleDisabledCopyWith(_$_QSubtitleDisabled value,
          $Res Function(_$_QSubtitleDisabled) then) =
      __$$_QSubtitleDisabledCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_QSubtitleDisabledCopyWithImpl<$Res>
    extends _$QSubtitleConfigCopyWithImpl<$Res>
    implements _$$_QSubtitleDisabledCopyWith<$Res> {
  __$$_QSubtitleDisabledCopyWithImpl(
      _$_QSubtitleDisabled _value, $Res Function(_$_QSubtitleDisabled) _then)
      : super(_value, (v) => _then(v as _$_QSubtitleDisabled));

  @override
  _$_QSubtitleDisabled get _value => super._value as _$_QSubtitleDisabled;
}

/// @nodoc

class _$_QSubtitleDisabled implements _QSubtitleDisabled {
  const _$_QSubtitleDisabled();

  @override
  String toString() {
    return 'QSubtitleConfig.disabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_QSubtitleDisabled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disabled,
    required TResult Function() enabled,
    required TResult Function(String subtitle) editable,
  }) {
    return disabled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
  }) {
    return disabled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
    required TResult orElse(),
  }) {
    if (disabled != null) {
      return disabled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_QSubtitleDisabled value) disabled,
    required TResult Function(_QSubtitleEnabled value) enabled,
    required TResult Function(_QSubtitleEditable value) editable,
  }) {
    return disabled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
  }) {
    return disabled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
    required TResult orElse(),
  }) {
    if (disabled != null) {
      return disabled(this);
    }
    return orElse();
  }
}

abstract class _QSubtitleDisabled implements QSubtitleConfig {
  const factory _QSubtitleDisabled() = _$_QSubtitleDisabled;
}

/// @nodoc
abstract class _$$_QSubtitleEnabledCopyWith<$Res> {
  factory _$$_QSubtitleEnabledCopyWith(
          _$_QSubtitleEnabled value, $Res Function(_$_QSubtitleEnabled) then) =
      __$$_QSubtitleEnabledCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_QSubtitleEnabledCopyWithImpl<$Res>
    extends _$QSubtitleConfigCopyWithImpl<$Res>
    implements _$$_QSubtitleEnabledCopyWith<$Res> {
  __$$_QSubtitleEnabledCopyWithImpl(
      _$_QSubtitleEnabled _value, $Res Function(_$_QSubtitleEnabled) _then)
      : super(_value, (v) => _then(v as _$_QSubtitleEnabled));

  @override
  _$_QSubtitleEnabled get _value => super._value as _$_QSubtitleEnabled;
}

/// @nodoc

class _$_QSubtitleEnabled implements _QSubtitleEnabled {
  const _$_QSubtitleEnabled();

  @override
  String toString() {
    return 'QSubtitleConfig.enabled()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_QSubtitleEnabled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disabled,
    required TResult Function() enabled,
    required TResult Function(String subtitle) editable,
  }) {
    return enabled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
  }) {
    return enabled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
    required TResult orElse(),
  }) {
    if (enabled != null) {
      return enabled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_QSubtitleDisabled value) disabled,
    required TResult Function(_QSubtitleEnabled value) enabled,
    required TResult Function(_QSubtitleEditable value) editable,
  }) {
    return enabled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
  }) {
    return enabled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
    required TResult orElse(),
  }) {
    if (enabled != null) {
      return enabled(this);
    }
    return orElse();
  }
}

abstract class _QSubtitleEnabled implements QSubtitleConfig {
  const factory _QSubtitleEnabled() = _$_QSubtitleEnabled;
}

/// @nodoc
abstract class _$$_QSubtitleEditableCopyWith<$Res> {
  factory _$$_QSubtitleEditableCopyWith(_$_QSubtitleEditable value,
          $Res Function(_$_QSubtitleEditable) then) =
      __$$_QSubtitleEditableCopyWithImpl<$Res>;
  $Res call({String subtitle});
}

/// @nodoc
class __$$_QSubtitleEditableCopyWithImpl<$Res>
    extends _$QSubtitleConfigCopyWithImpl<$Res>
    implements _$$_QSubtitleEditableCopyWith<$Res> {
  __$$_QSubtitleEditableCopyWithImpl(
      _$_QSubtitleEditable _value, $Res Function(_$_QSubtitleEditable) _then)
      : super(_value, (v) => _then(v as _$_QSubtitleEditable));

  @override
  _$_QSubtitleEditable get _value => super._value as _$_QSubtitleEditable;

  @override
  $Res call({
    Object? subtitle = freezed,
  }) {
    return _then(_$_QSubtitleEditable(
      subtitle == freezed
          ? _value.subtitle
          : subtitle // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_QSubtitleEditable implements _QSubtitleEditable {
  const _$_QSubtitleEditable(this.subtitle);

  @override
  final String subtitle;

  @override
  String toString() {
    return 'QSubtitleConfig.editable(subtitle: $subtitle)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_QSubtitleEditable &&
            const DeepCollectionEquality().equals(other.subtitle, subtitle));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(subtitle));

  @JsonKey(ignore: true)
  @override
  _$$_QSubtitleEditableCopyWith<_$_QSubtitleEditable> get copyWith =>
      __$$_QSubtitleEditableCopyWithImpl<_$_QSubtitleEditable>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() disabled,
    required TResult Function() enabled,
    required TResult Function(String subtitle) editable,
  }) {
    return editable(subtitle);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
  }) {
    return editable?.call(subtitle);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? disabled,
    TResult Function()? enabled,
    TResult Function(String subtitle)? editable,
    required TResult orElse(),
  }) {
    if (editable != null) {
      return editable(subtitle);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_QSubtitleDisabled value) disabled,
    required TResult Function(_QSubtitleEnabled value) enabled,
    required TResult Function(_QSubtitleEditable value) editable,
  }) {
    return editable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
  }) {
    return editable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_QSubtitleDisabled value)? disabled,
    TResult Function(_QSubtitleEnabled value)? enabled,
    TResult Function(_QSubtitleEditable value)? editable,
    required TResult orElse(),
  }) {
    if (editable != null) {
      return editable(this);
    }
    return orElse();
  }
}

abstract class _QSubtitleEditable implements QSubtitleConfig {
  const factory _QSubtitleEditable(final String subtitle) =
      _$_QSubtitleEditable;

  String get subtitle => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$_QSubtitleEditableCopyWith<_$_QSubtitleEditable> get copyWith =>
      throw _privateConstructorUsedError;
}
